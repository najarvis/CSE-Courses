/**    A class of bags whose entries are stored in a fixed-size array.    INITIAL, INCOMPLETE DEFINITION; no security checks    @version 4.0    @author Frank M. Carrano*/public final class ArrayBag1<T> implements BagInterface<T>{	private final T[] bag;	private int numberOfEntries;	private static final int DEFAULT_CAPACITY = 25;	/** Creates an empty bag whose capacity is 25. */	public ArrayBag1() 	{		this(DEFAULT_CAPACITY);	} // end default constructor	/** Creates an empty bag having a given capacity.       @param capacity  The integer capacity desired. */	public ArrayBag1(int desiredCapacity)	{      // The cast is safe because the new array contains null entries      @SuppressWarnings("unchecked")      T[] tempBag = (T[])new Object[desiredCapacity]; // Unchecked cast      bag = tempBag;      numberOfEntries = 0;	} // end constructor	/** Adds a new entry to this bag.       @param newEntry  The object to be added as a new entry.       @return  True if the addition is successful, or false if not. */	public boolean add(T newEntry)	{      boolean result = true;      if (isArrayFull())      {         result = false;      }      else      {  // Assertion: result is true here         bag[numberOfEntries] = newEntry;         numberOfEntries++;      } // end if            return result;	} // end add   	/** Retrieves all entries that are in this bag.       @return  A newly allocated array of all the entries in this bag. */	public T[] toArray()  	{      // The cast is safe because the new array contains null entries.      @SuppressWarnings("unchecked")      T[] result = (T[])new Object[numberOfEntries]; // Unchecked cast            for (int index = 0; index < numberOfEntries; index++)      {         result[index] = bag[index];      } // end for            return result;      // Note: The body of this method could consist of one return statement,      // if you call Arrays.copyOf	} // end toArray	   // Returns true if the array bag is full, or false if not.	private boolean isArrayFull()	{		return numberOfEntries >= bag.length;	} // end isArrayFull// STUBS:	/** Sees whether this bag is empty.	    @return  True if this bag is empty, or false if not */	public boolean isEmpty() 	{		return (numberOfEntries == 0);	} // end isEmpty	/** Gets the number of entries currently in this bag.	    @return  The integer number of entries currently in this bag */	public int getCurrentSize() 	{		return numberOfEntries;	} // end getCurrentSize	/** Removes one unspecified entry from this bag, if possible.       @return  Either the removed entry, if the removal                was successful, or null */	public T remove()   {		T toReturn = null;		if (!isEmpty()){			numberOfEntries--;			toReturn = bag[numberOfEntries];			bag[numberOfEntries] = null;		}		return toReturn;   } // end remove   	/** Removes one occurrence of a given entry from this bag.       @param anEntry  The entry to be removed       @return  True if the removal was successful, or false otherwise */   public boolean remove(T anEntry)   {	   int swapIndex = numberOfEntries;	   for (int i = 0; i < bag.length; i++){		   if (bag[i].equals(anEntry)){			   swapIndex = i;			   break;		   }		   		   // The object was not found in the bag.		   if (i == bag.length - 1){			   return false;		   }	   }	   	   // Move the last element to the index we found	   bag[swapIndex] = bag[numberOfEntries-1];	   	   // Change the last element to null	   bag[numberOfEntries] = null;	   numberOfEntries--;	   	   return true;	     } // end remove		/** Removes all entries from this bag. */	public void clear()   {      numberOfEntries = 0;      for (int i = 0; i < bag.length; i++){    	  bag[i] = null;      }   } // end clear		/** Counts the number of times a given entry appears in this bag.		 @param anEntry  The entry to be counted		 @return  The number of times anEntry appears in the bag */	public int getFrequencyOf(T anEntry)   {		int sum = 0;		for (int i = 0; i < numberOfEntries; i++){			if (bag[i].equals(anEntry)) sum += 1;		}		return sum;   } // end getFrequencyOf		/** Tests whether this bag contains a given entry.		 @param anEntry  The entry to locate		 @return  True if this bag contains anEntry, or false otherwise */	public boolean contains(T anEntry)   {      return getFrequencyOf(anEntry) > 0;   } // end contains		public static void main(String[] args){		ArrayBag1 TestBag = new ArrayBag1();		TestBag.add(1);		TestBag.add(26);		TestBag.add(3);		TestBag.add(4);		TestBag.add(3);		TestBag.add(3);		TestBag.add(3);				System.out.println(TestBag.contains(3));		System.out.println(TestBag.contains(2));		System.out.println(TestBag.getFrequencyOf(3));				System.out.println(TestBag.remove());		System.out.println(TestBag.remove(26));		System.out.println(TestBag.getFrequencyOf(3));		System.out.println(TestBag.getFrequencyOf(26));	}} // end ArrayBag1