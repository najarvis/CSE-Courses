/** * A class of bags whose entries are stored in a chain of linked nodes. The bag * is never full. *  * @author Frank M. Carrano * @version 4.0 */public final class LinkedBag1<T> implements BagInterface<T> {	private class Node {		private T data; // Entry in bag		private Node next; // Link to next node		private Node(T dataPortion) {			this(dataPortion, null);		} // end constructor		private Node(T dataPortion, Node nextNode) {			data = dataPortion;			next = nextNode;		} // end constructor	} // end Node	private Node firstNode; // Reference to first node	private int numberOfEntries;	public LinkedBag1() {		firstNode = null;		numberOfEntries = 0;	} // end default constructor	/**	 * Adds a new entry to this bag.	 * 	 * @param newEntry	 *            The object to be added as a new entry.	 * @return True.	 */	public boolean add(T newEntry) // OutOfMemoryError possible	{		// Add to beginning of chain:		Node newNode = new Node(newEntry);		newNode.next = firstNode; // Make new node reference rest of chain									// (firstNode is null if chain is empty)		firstNode = newNode; // New node is at beginning of chain		numberOfEntries++;		return true;	} // end add	/**	 * Retrieves all entries that are in this bag.	 * 	 * @return A newly allocated array of all the entries in this bag.	 */	public T[] toArray() {		// The cast is safe because the new array contains null entries.		@SuppressWarnings("unchecked")		T[] result = (T[]) new Object[numberOfEntries]; // Unchecked cast		int index = 0;		Node currentNode = firstNode;		while ((index < numberOfEntries) && (currentNode != null)) {			result[index] = currentNode.data;			index++;			currentNode = currentNode.next;		} // end while		return result;		// Note: The body of this method could consist of one return statement,		// if you call Arrays.copyOf	} // end toArray	/**	 * Sees whether this bag is empty.	 * 	 * @return True if the bag is empty, or false if not.	 */	public boolean isEmpty() {		return numberOfEntries == 0;	} // end isEmpty	/**	 * Gets the number of entries currently in this bag.	 * 	 * @return The integer number of entries currently in the bag.	 */	public int getCurrentSize() {		return numberOfEntries;	} // end getCurrentSize	/**	 * Removes one unspecified entry from this bag, if possible.	 * 	 * @return Either the removed entry, if the removal was successful, or null.	 */	public T remove() {		T result = null;		if (isEmpty()) return result;				result = firstNode.data;		firstNode = firstNode.next;		numberOfEntries--;				return result;	} // end remove	/**	 * Removes one occurrence of a given entry from this bag.	 * 	 * @param anEntry	 *            The entry to be removed.	 * @return True if the removal was successful, or false otherwise.	 */	public boolean remove(T anEntry) {		if (isEmpty()) return false;				Node n = firstNode;		while (n != null){			if (n.data.equals(anEntry)){				n.data = firstNode.data;				firstNode = firstNode.next;				numberOfEntries--;				return true;			}			n = n.next;		}				return false;	} // end remove	/** Removes all entries from this bag. */	public void clear() {		numberOfEntries = 0;		firstNode = null;	} // end clear	/**	 * Counts the number of times a given entry appears in this bag.	 * 	 * @param anEntry The entry to be counted.	 * @return The number of times anEntry appears in the bag.	 */	public int getFrequencyOf(T anEntry) {		int freq = 0;		Node n = firstNode;		while (n != null){			if (n.data.equals(anEntry))				freq++;			n = n.next;		}		return freq;	} // end getFrequencyOf	/**	 * Tests whether this bag contains a given entry.	 * 	 * @param anEntry	 *            The entry to locate.	 * @return True if the bag contains anEntry, or false otherwise.	 */	public boolean contains(T anEntry) {		boolean found = false;		Node currentNode = firstNode;		while (!found && (currentNode != null)) {			if (anEntry.equals(currentNode.data))				found = true;			else				currentNode = currentNode.next;		}		return found;	} // end contains		/**	 * Searches for and finds a node that is holds a specific data value	 * @param anEntry - The value to search for	 * @return The node that contains the value. If none are found, null is returned.	 */	public Node find(T anEntry){		if (isEmpty()) return null;				Node n = firstNode;		while (n != null){			if (n.data.equals(anEntry))				return n;			n = n.next;					}		return n; // n should be null at this point.	}		/**	 * removes every instance of a specific entry from the linked bag	 * @param anEntry - The entry to remove	 * @return True if at least one value was removed.	 */	public boolean removeEvery(T anEntry){		boolean removed = false;		while (remove(anEntry))			removed = true;		return removed;	}		/**	 * Adds a value to the end of the linked bag	 * @param anEntry - the entry to add	 * @return true	 */	public boolean addRear(T anEntry){		Node n = new Node(anEntry);		if (isEmpty()){			firstNode = n;		} else {			Node curr = firstNode;			while (curr.next != null){				curr = curr.next;			}			curr.next = n;			numberOfEntries++;		}		return true;	}		/**	 * Returns the intersection of two linked bags	 * @param other - the other linked bag	 * @return the intersection of the two bags	 */	public LinkedBag1<T> intersections(LinkedBag1<T> other){		LinkedBag1<T> toReturn = new LinkedBag1<T>();		Node n = firstNode;				while (n != null){			int t = (int) clamp(getFrequencyOf(n.data), other.getFrequencyOf(n.data), false);			if (!toReturn.contains(n.data)){ // To make sure we are not adding duplicates.				for (int i = 0; i < t; i++){					toReturn.add(n.data);				}			}			n = n.next;		}				return toReturn;	}		/**	 * Helper method to clamp to a high or low value	 * @param val1 - First Value	 * @param val2 - Second Value	 * @param high - If this is true, return the higher of the two, if not, return the lower.	 * @return Return the higher or lower value depending on the high parameter.	 */	private static double clamp(double val1, double val2, boolean high){		if (high) return Math.max(val1, val2);		else return Math.min(val1, val2);	}			/**	 * Test if two Linked bags are equivalent to each other.	 * @param other - The linked bag on which to test equivalence	 * @return - true if the two linked bags are equal, false if not.	 */	public boolean equals(LinkedBag1<T> other){		return intersections(other).numberOfEntries == numberOfEntries;	}} // end LinkedBag1